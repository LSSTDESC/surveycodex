{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome to <code>surveycodex</code>","text":"<p><code>surveycodex</code> is a tiny package containing useful parameters from main galaxy surveys (with units).</p> <p>The goal of this project is to provide a Python library with minimal dependencies that centralises galaxy survey properties with adequate reference. Such information tends to be scattered in many places or is often copy/pasted without all of the relevant information like units or sources.</p>"},{"location":"index.html#command-line-interface","title":"Command line interface","text":"<p>Pretty print the available surveys and associated filters in the terminal</p> <pre><code>surveycodex\n</code></pre>"},{"location":"index.html#options","title":"Options","text":"<ul> <li><code>-s &lt;survey&gt;</code>: print information for a given survey</li> <li><code>--refs</code>: print the source for each parameter</li> <li><code>--rich</code>: use pretty printing for the terminal (needs the <code>rich</code> library installed)</li> <li><code>-h, --help</code>: get help</li> </ul>"},{"location":"index.html#examples","title":"Examples","text":"<pre><code>surveycodex -s LSST         # LSST info\nsurveycodex --refs          # all surveys info with refs\nsurveycodex --refs -s HSC   # HSC info with refs\nsurveycodex -s LSST --rich  # pretty print rich terminal output for LSST survey info\n</code></pre>"},{"location":"index.html#installation","title":"Installation","text":"<pre><code>python -m pip install -U surveycodex\n</code></pre>"},{"location":"index.html#optional-installation","title":"Optional installation","text":""},{"location":"index.html#scripts","title":"Scripts","text":"<p>To run the Python scripts from the <code>script</code> folder, use the extra install</p> <pre><code>python -m pip install -U surveycodex[scripts]\n</code></pre>"},{"location":"index.html#developers","title":"Developers","text":"<p>The developer tools needed to perform tests and linting and compile the docs locally can be installed with</p> <pre><code>python -m pip install -U surveycodex[dev]\n</code></pre>"},{"location":"index.html#rich-display-new-in-v11","title":"Rich display (new in v1.1)","text":"<p>For a better terminal experience, install the <code>rich</code> library and use it together with the <code>--rich</code> option from <code>surveycodex</code></p> <pre><code>python -m pip install rich\n</code></pre>"},{"location":"parameters.html","title":"<code>surveycodex</code> supported parameters","text":"<p>The following page describes the parameters of the photometric surveys and their filters exposed in surveycodex, what type and unit they should be specified with.</p>"},{"location":"parameters.html#survey-parameters","title":"Survey parameters","text":""},{"location":"parameters.html#input-parameters","title":"Input parameters","text":"<p>The following parameters are required in the YAML file describing any survey to build the <code>Survey</code> class in <code>surveycodex</code>.</p> parameter name type units description name str \u2013 The classical name or abbreviation for the survey. Most often this is how the survey is referred to. In case of an ambiguity, for instance when a survey has several instruments, the name of the instrument should be added as a suffix (e.g. <code>Euclid_VIS</code>). description str \u2013 A bit of context around the survey: on which telescope, with which instrument, wide survey or a specific deep field. pixel_scale float arcsec / pixel Size of a square pixel on the sky. gain float e<sup>-</sup> / ADU Conversion factor between the photo-electrons received by the camera and the digital counts after the amplification of the electronics. mirror_diameter float m Primary mirror diameter, in meters. obscuration float dimensionless Proportion of the total area of the telescope that is obscured by the position of secondary mirrors, lenses, camera, etc. This parameter is used to compute the effective area of the telescope. zeropoint_airmass float dimensionless Airmass value at which the zeropoint is computed. The airmass is commonly defined as the optical path length through the atmosphere relative to the zenith path length. For space surveys, this value is set to 0.0. references dict[str] \u2013 mandatory but can be left as an empty string \u2013 Source of each parameter value (survey or filter), specified as a link (to an article or website) and a comment string. See the bottom the dummy YAML file for layout."},{"location":"parameters.html#computed-parameters","title":"Computed parameters","text":"<p>The following parameters are computed after initialisation of the <code>Survey</code> class, from the mandatory info.</p> parameter name type units description available_filters list[str] \u2013 List of available filter names for the survey. effective area float m<sup>2</sup> Actual area receiving light after taking into account the size of the primary mirror and the obscuration."},{"location":"parameters.html#filter-parameters","title":"Filter parameters","text":"<p>The following parameters are required in the YAML file describing any filter of a given survey, to build the <code>Filter</code> class in <code>surveycodex</code>.</p> parameter name type units description name str \u2013 Name of the filter sky_brightness float mag / arcsec<sup>2</sup> Average sky brightness computed for the survey and this filter. The moon conditions under which this number was computed will be given as a comment in the yaml file. full_exposure_time int/float s Average exposure time of the filter on the same spot in the sky over the course of the survey. psf_fwhm float arcsec Average full width at half-maximum (FWHM) of the point spread function (PSF) over the filter. zeropoint float mag The zeropoint value for most surveys is a reference magnitude computed as the magnitude in the AB system (see this reference) collected on the instrument effective area in one second. It takes into account the filter bandwidth and a classical atmosphere for ground based surveys, using the <code>speclite</code> library, at the airmass given by the survey <code>zeropoint_airmass</code>. For the remaining surveys it is extracted from corresponding the references (see <code>references</code> parameter). effective_wavelength float nm optional \u2013 Wavelength computed as a weighted average of the full passband throughput over the wavelength range. The throughput takes into account the transmission of the filter, the transmittance of the optics, the CCD efficiency as well as a standard atmospheric extinction model."},{"location":"parameters.html#yaml-file-layout","title":"YAML file layout","text":""},{"location":"parameters.html#directives","title":"Directives","text":"<p>The information for a given survey should be provided as an individual YAML file, with the following layout.</p> <ul> <li>survey information first</li> <li>list of filters below</li> <li>references last</li> <li>one parameter per line</li> <li>strings should be quoted with <code>\" \"</code></li> <li>indentation (2 spaces) means sub-list</li> <li>comments (starts with <code>#</code>) are put on new lines</li> </ul>"},{"location":"parameters.html#example","title":"Example","text":"<p>An toy example for a dummy survey called <code>Survey42</code> with two filters <code>a</code> and <code>b</code> is shown below.</p> <pre><code># Content of Survey42.yaml\nname: \"Survey42\"\ndescription: \"The Survey42 was done on the XXX telescope with the YYY instrument\"\npixel_scale: 0.2\ngain: 2.0\nmirror_diameter: 4.2\nobscuration: 0.2\nzeropoint_airmass: 1.2\nfilters:\n  a:\n    name: \"a\"\n    sky_brightness: 19.4\n    full_exposure_time: 500\n    zeropoint: 26.90\n    psf_fwhm: 1.1\n    effective_wavelength: 500.00\n  b:\n    name: \"b\"\n    sky_brightness: 18.6\n    full_exposure_time: 500\n    zeropoint: 27.36\n    psf_fwhm: 1.2\n    effective_wavelength: 600.00\nreferences:\n  pixel_scale:\n    link: \"https://link-to-the-pixelscale-ref.com\"\n    comment: \"See section 2.4\"\n  gain:\n    link: \"https://link-to-the-gain-info.org\"\n    comment: \"\"\n  psf_fwhm:\n    link: \"https://link-to-filters-refs.org\"\n    comment: \"\"\n# goal is to have a reference per parameter, survey or filter-wise...\n</code></pre>"},{"location":"api/filter.html","title":"surveycodex.filter","text":""},{"location":"api/filter.html#surveycodex.filter.Filter","title":"<code>Filter</code>  <code>dataclass</code>","text":"<p>A dataclass containing the main filter parameters</p> Source code in <code>surveycodex/filter.py</code> <pre><code>@dataclass(frozen=True)\nclass Filter:\n    \"\"\"A dataclass containing the main filter parameters\"\"\"\n\n    name: str\n    \"The filter name\"\n    psf_fwhm: Quantity\n    \"The full-width at half maximum of the PSF\"\n    zeropoint: Quantity\n    \"The zeropoint magnitude computed with the speclite library\"\n    sky_brightness: Quantity\n    \"Mean sky brightness\"\n    full_exposure_time: Quantity\n    \"Mean time spent on the sky on a random survey location\"\n    effective_wavelength: Optional[Quantity] = None\n    \"Filter effective wavelength computed from the complete throughput information\"\n\n    @classmethod\n    def from_dict(cls, filter_info):\n        \"\"\"Constructor for the Filter dataclass\n\n        Makes sure each of the filter attributes gets the appropriate units\n        to improve definition and avoid confusion and conversion issues.\n\n        Parameters\n        ----------\n        filter_info: dict\n            Dictionary with the filter informations\n\n        Returns\n        -------\n        Filter\n            A Filter object filled with the given information\n\n        \"\"\"\n        name = filter_info[\"name\"]\n        psf_fwhm = filter_info[\"psf_fwhm\"] * u.arcsec\n        zeropoint = filter_info[\"zeropoint\"] * u.mag\n        sky_brightness = filter_info[\"sky_brightness\"] * (u.mag / u.arcsec**2)\n        full_exposure_time = filter_info[\"full_exposure_time\"] * u.s\n        wavelength = filter_info.get(\"effective_wavelength\")\n        wavelength = wavelength if wavelength is None else wavelength * u.nm\n\n        return cls(\n            name,\n            psf_fwhm,\n            zeropoint,\n            sky_brightness,\n            full_exposure_time,\n            wavelength,\n        )\n\n    def __str__(self):\n        filter_repr = f\"-= {self.name} filter =-\\n\"\n        printed_params = [\n            f\"  {key:&lt;20} = {val}\"\n            for key, val in self.__dict__.items()\n            if key not in (\"name\",)\n        ]\n        filter_repr += \"\\n\".join(printed_params)\n        return filter_repr\n\n    def __repr__(self):\n        return f\"Filter {self.name}\"\n</code></pre>"},{"location":"api/filter.html#surveycodex.filter.Filter.effective_wavelength","title":"<code>effective_wavelength: Optional[Quantity] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Filter effective wavelength computed from the complete throughput information</p>"},{"location":"api/filter.html#surveycodex.filter.Filter.full_exposure_time","title":"<code>full_exposure_time: Quantity</code>  <code>instance-attribute</code>","text":"<p>Mean time spent on the sky on a random survey location</p>"},{"location":"api/filter.html#surveycodex.filter.Filter.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>The filter name</p>"},{"location":"api/filter.html#surveycodex.filter.Filter.psf_fwhm","title":"<code>psf_fwhm: Quantity</code>  <code>instance-attribute</code>","text":"<p>The full-width at half maximum of the PSF</p>"},{"location":"api/filter.html#surveycodex.filter.Filter.sky_brightness","title":"<code>sky_brightness: Quantity</code>  <code>instance-attribute</code>","text":"<p>Mean sky brightness</p>"},{"location":"api/filter.html#surveycodex.filter.Filter.zeropoint","title":"<code>zeropoint: Quantity</code>  <code>instance-attribute</code>","text":"<p>The zeropoint magnitude computed with the speclite library</p>"},{"location":"api/filter.html#surveycodex.filter.Filter.from_dict","title":"<code>from_dict(filter_info)</code>  <code>classmethod</code>","text":"<p>Constructor for the Filter dataclass</p> <p>Makes sure each of the filter attributes gets the appropriate units to improve definition and avoid confusion and conversion issues.</p>"},{"location":"api/filter.html#surveycodex.filter.Filter.from_dict--parameters","title":"Parameters","text":"<p>filter_info: dict     Dictionary with the filter informations</p>"},{"location":"api/filter.html#surveycodex.filter.Filter.from_dict--returns","title":"Returns","text":"<p>Filter     A Filter object filled with the given information</p> Source code in <code>surveycodex/filter.py</code> <pre><code>@classmethod\ndef from_dict(cls, filter_info):\n    \"\"\"Constructor for the Filter dataclass\n\n    Makes sure each of the filter attributes gets the appropriate units\n    to improve definition and avoid confusion and conversion issues.\n\n    Parameters\n    ----------\n    filter_info: dict\n        Dictionary with the filter informations\n\n    Returns\n    -------\n    Filter\n        A Filter object filled with the given information\n\n    \"\"\"\n    name = filter_info[\"name\"]\n    psf_fwhm = filter_info[\"psf_fwhm\"] * u.arcsec\n    zeropoint = filter_info[\"zeropoint\"] * u.mag\n    sky_brightness = filter_info[\"sky_brightness\"] * (u.mag / u.arcsec**2)\n    full_exposure_time = filter_info[\"full_exposure_time\"] * u.s\n    wavelength = filter_info.get(\"effective_wavelength\")\n    wavelength = wavelength if wavelength is None else wavelength * u.nm\n\n    return cls(\n        name,\n        psf_fwhm,\n        zeropoint,\n        sky_brightness,\n        full_exposure_time,\n        wavelength,\n    )\n</code></pre>"},{"location":"api/helpers.html","title":"surveycodex.helpers","text":""},{"location":"api/survey.html","title":"surveycodex.survey","text":""},{"location":"api/survey.html#surveycodex.survey.Survey","title":"<code>Survey</code>  <code>dataclass</code>","text":"<p>A dataclass for storing the parameters of a survey</p> Source code in <code>surveycodex/survey.py</code> <pre><code>@dataclass(frozen=True)\nclass Survey:\n    \"\"\"A dataclass for storing the parameters of a survey\"\"\"\n\n    name: str\n    \"The survey name\"\n    description: str\n    \"The survey description with telescope/instrument information\"\n    _filters: Dict[str, Filter]\n    \"A private dictionary containing the survey filters\"\n    pixel_scale: Quantity\n    \"The pixel scale of the survey\"\n    mirror_diameter: Quantity\n    \"The mirror diameter\"\n    gain: Quantity\n    \"The gain in electron/ADU\"\n    obscuration: Quantity\n    \"The total obscuration created by the instrument pieces\"\n    zeropoint_airmass: Quantity\n    \"The zeropoint airmass\"\n    available_filters: List[str] = field(init=False)\n    \"The list of survey filters\"\n    effective_area: Quantity = field(init=False)\n    \"The survey instrument effective area on the sky computed from the obscuration\"\n    references: Dict[str, Dict[str, str]]\n    \"Dictionary of references for each parameter specified in surveycodex\"\n\n    @classmethod\n    def from_yaml(cls, yaml_file: str):\n        \"\"\"Constructor for the Survey class\n\n        Parameters\n        ----------\n        yaml_file: pathlike\n            Filepath to YAML file containing the survey info\n\n        Returns\n        -------\n        Survey\n            A `Survey` instance filled with the information as attributes\n\n        \"\"\"\n        with open(yaml_file) as f:\n            data = yaml.safe_load(f)\n\n        filters = Survey._construct_filter_dict(data)\n        pixel_scale = data[\"pixel_scale\"] * u.arcsec\n        mirror_diameter = data[\"mirror_diameter\"] * u.m\n        gain = data[\"gain\"] * u.electron / u.adu\n        obscuration = data[\"obscuration\"] * u.dimensionless_unscaled\n        zeropoint_airmass = data[\"zeropoint_airmass\"] * u.dimensionless_unscaled\n\n        return cls(\n            data[\"name\"],\n            data[\"description\"],\n            filters,\n            pixel_scale,\n            mirror_diameter,\n            gain,\n            obscuration,\n            zeropoint_airmass,\n            data[\"references\"],\n        )\n\n    def __str__(self):\n        n = len(self.name)\n        survey_repr = \"-\" * (n + 4) + \"\\n\"\n        survey_repr += f\"| {self.name} |\"\n        survey_repr += f\" {self.description}\\n\"\n        survey_repr += \"-\" * (n + 4) + \"\\n\"\n        printed_params = [\n            f\"  {key:&lt;20} = {val}\"\n            for key, val in self.__dict__.items()\n            if key not in (\"name\", \"description\", \"_filters\", \"references\")\n        ]\n        survey_repr += \"\\n\".join(printed_params)\n        return survey_repr\n\n    def __repr__(self):\n        return f\"Survey {self.name}\"\n\n    @staticmethod\n    def _construct_filter_dict(survey_dict):\n        \"\"\"Create a custom dictionary for the survey filters\n\n        Parameters\n        ----------\n        survey_dict: dict\n            Dictionnary of the survey parameters, including the definition of the filters\n\n        Returns\n        -------\n        dict\n            Dictionary of the survey Filter instances\n\n        \"\"\"\n        return {\n            fname: Filter.from_dict(fdict)\n            for fname, fdict in survey_dict[\"filters\"].items()\n        }\n\n    def __post_init__(self):\n        \"\"\"Set attributes computed after class is constructed\"\"\"\n        available_filters = list(self._filters.keys())\n        object.__setattr__(self, \"available_filters\", available_filters)\n\n        total_area = math.pi * (self.mirror_diameter * 0.5) ** 2\n        effective_area = total_area * (1 - self.obscuration)\n        object.__setattr__(self, \"effective_area\", effective_area)\n\n    def get_filter(self, filter_name):\n        \"\"\"Getter method to retrieve a Filter object\n\n        Parameters\n        ----------\n        filter_name : str\n            Name of a filter chosen among the `available_filters` attribute\n\n        Returns\n        -------\n        Filter\n            Corresponding `Filter` dataclass\n\n        Raises\n        ------\n        ValueError\n            The requested filter does not exist or is not available in surveycodex\n\n        \"\"\"\n        if filter_name not in self.available_filters:\n            raise ValueError(\n                \"Please check the filter name. \"\n                f\"The available filters for {self.name} \"\n                f\"are {self.available_filters}\"\n            )\n\n        return self._filters[filter_name]\n</code></pre>"},{"location":"api/survey.html#surveycodex.survey.Survey.available_filters","title":"<code>available_filters: List[str] = field(init=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The list of survey filters</p>"},{"location":"api/survey.html#surveycodex.survey.Survey.description","title":"<code>description: str</code>  <code>instance-attribute</code>","text":"<p>The survey description with telescope/instrument information</p>"},{"location":"api/survey.html#surveycodex.survey.Survey.effective_area","title":"<code>effective_area: Quantity = field(init=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The survey instrument effective area on the sky computed from the obscuration</p>"},{"location":"api/survey.html#surveycodex.survey.Survey.gain","title":"<code>gain: Quantity</code>  <code>instance-attribute</code>","text":"<p>The gain in electron/ADU</p>"},{"location":"api/survey.html#surveycodex.survey.Survey.mirror_diameter","title":"<code>mirror_diameter: Quantity</code>  <code>instance-attribute</code>","text":"<p>The mirror diameter</p>"},{"location":"api/survey.html#surveycodex.survey.Survey.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>The survey name</p>"},{"location":"api/survey.html#surveycodex.survey.Survey.obscuration","title":"<code>obscuration: Quantity</code>  <code>instance-attribute</code>","text":"<p>The total obscuration created by the instrument pieces</p>"},{"location":"api/survey.html#surveycodex.survey.Survey.pixel_scale","title":"<code>pixel_scale: Quantity</code>  <code>instance-attribute</code>","text":"<p>The pixel scale of the survey</p>"},{"location":"api/survey.html#surveycodex.survey.Survey.references","title":"<code>references: Dict[str, Dict[str, str]]</code>  <code>instance-attribute</code>","text":"<p>Dictionary of references for each parameter specified in surveycodex</p>"},{"location":"api/survey.html#surveycodex.survey.Survey.zeropoint_airmass","title":"<code>zeropoint_airmass: Quantity</code>  <code>instance-attribute</code>","text":"<p>The zeropoint airmass</p>"},{"location":"api/survey.html#surveycodex.survey.Survey.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Set attributes computed after class is constructed</p> Source code in <code>surveycodex/survey.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Set attributes computed after class is constructed\"\"\"\n    available_filters = list(self._filters.keys())\n    object.__setattr__(self, \"available_filters\", available_filters)\n\n    total_area = math.pi * (self.mirror_diameter * 0.5) ** 2\n    effective_area = total_area * (1 - self.obscuration)\n    object.__setattr__(self, \"effective_area\", effective_area)\n</code></pre>"},{"location":"api/survey.html#surveycodex.survey.Survey.from_yaml","title":"<code>from_yaml(yaml_file)</code>  <code>classmethod</code>","text":"<p>Constructor for the Survey class</p>"},{"location":"api/survey.html#surveycodex.survey.Survey.from_yaml--parameters","title":"Parameters","text":"<p>yaml_file: pathlike     Filepath to YAML file containing the survey info</p>"},{"location":"api/survey.html#surveycodex.survey.Survey.from_yaml--returns","title":"Returns","text":"<p>Survey     A <code>Survey</code> instance filled with the information as attributes</p> Source code in <code>surveycodex/survey.py</code> <pre><code>@classmethod\ndef from_yaml(cls, yaml_file: str):\n    \"\"\"Constructor for the Survey class\n\n    Parameters\n    ----------\n    yaml_file: pathlike\n        Filepath to YAML file containing the survey info\n\n    Returns\n    -------\n    Survey\n        A `Survey` instance filled with the information as attributes\n\n    \"\"\"\n    with open(yaml_file) as f:\n        data = yaml.safe_load(f)\n\n    filters = Survey._construct_filter_dict(data)\n    pixel_scale = data[\"pixel_scale\"] * u.arcsec\n    mirror_diameter = data[\"mirror_diameter\"] * u.m\n    gain = data[\"gain\"] * u.electron / u.adu\n    obscuration = data[\"obscuration\"] * u.dimensionless_unscaled\n    zeropoint_airmass = data[\"zeropoint_airmass\"] * u.dimensionless_unscaled\n\n    return cls(\n        data[\"name\"],\n        data[\"description\"],\n        filters,\n        pixel_scale,\n        mirror_diameter,\n        gain,\n        obscuration,\n        zeropoint_airmass,\n        data[\"references\"],\n    )\n</code></pre>"},{"location":"api/survey.html#surveycodex.survey.Survey.get_filter","title":"<code>get_filter(filter_name)</code>","text":"<p>Getter method to retrieve a Filter object</p>"},{"location":"api/survey.html#surveycodex.survey.Survey.get_filter--parameters","title":"Parameters","text":"<p>filter_name : str     Name of a filter chosen among the <code>available_filters</code> attribute</p>"},{"location":"api/survey.html#surveycodex.survey.Survey.get_filter--returns","title":"Returns","text":"<p>Filter     Corresponding <code>Filter</code> dataclass</p>"},{"location":"api/survey.html#surveycodex.survey.Survey.get_filter--raises","title":"Raises","text":"<p>ValueError     The requested filter does not exist or is not available in surveycodex</p> Source code in <code>surveycodex/survey.py</code> <pre><code>def get_filter(self, filter_name):\n    \"\"\"Getter method to retrieve a Filter object\n\n    Parameters\n    ----------\n    filter_name : str\n        Name of a filter chosen among the `available_filters` attribute\n\n    Returns\n    -------\n    Filter\n        Corresponding `Filter` dataclass\n\n    Raises\n    ------\n    ValueError\n        The requested filter does not exist or is not available in surveycodex\n\n    \"\"\"\n    if filter_name not in self.available_filters:\n        raise ValueError(\n            \"Please check the filter name. \"\n            f\"The available filters for {self.name} \"\n            f\"are {self.available_filters}\"\n        )\n\n    return self._filters[filter_name]\n</code></pre>"},{"location":"api/utilities.html","title":"surveycodex.utilities","text":""},{"location":"api/utilities.html#surveycodex.utilities.mag2counts","title":"<code>mag2counts(magnitude, survey, filter, exposure_time=None)</code>","text":"<p>Convert source magnitude to electron counts for a given survey filter</p> <p>To perform the computation, we use the filter zeropoint computed with <code>speclite</code> at a given airmass under classical atmospheric conditions and by default integrated over the survey lifetime.</p> <p>An exposure time can be provided to compute the corresponding counts instead of the full filter exposure time.</p> <p>Expect a rough estimate from this calculation since e.g. it does not take into account the atmospheric extinction. Therefore the result is cast to an integer.</p>"},{"location":"api/utilities.html#surveycodex.utilities.mag2counts--parameters","title":"Parameters","text":"<p>magnitude: float     magnitude of source survey: str or Survey     Name of a given survey or Survey instance filter: str or Filter     Name of the survey filter or Filter instance exposure_time: float or Quantity[float] (optional)     Exposure time of the filter in seconds.     If not provided, the full filter exposure time is used.</p>"},{"location":"api/utilities.html#surveycodex.utilities.mag2counts--returns","title":"Returns","text":"<p>Quantity[int]     The corresponding flux in electron counts</p>"},{"location":"api/utilities.html#surveycodex.utilities.mag2counts--example","title":"Example","text":"<p>from surveycodex.utilities import mag2counts mag2counts(24, \"LSST\", \"g\")"},{"location":"api/utilities.html#surveycodex.utilities.mag2counts--references","title":"References","text":"<p>The <code>WeakLensingDeblending</code> package https://github.com/LSSTDESC/WeakLensingDeblending</p> Source code in <code>surveycodex/utilities.py</code> <pre><code>def mag2counts(magnitude, survey, filter, exposure_time=None):\n    \"\"\"Convert source magnitude to electron counts for a given survey filter\n\n    To perform the computation, we use the filter zeropoint computed\n    with `speclite` at a given airmass under classical atmospheric\n    conditions and by default integrated over the survey lifetime.\n\n    An exposure time can be provided to compute the corresponding counts\n    instead of the full filter exposure time.\n\n    Expect a rough estimate from this calculation since e.g. it does not\n    take into account the atmospheric extinction. Therefore the result\n    is cast to an integer.\n\n    Parameters\n    ----------\n    magnitude: float\n        magnitude of source\n    survey: str or Survey\n        Name of a given survey or Survey instance\n    filter: str or Filter\n        Name of the survey filter or Filter instance\n    exposure_time: float or Quantity[float] (optional)\n        Exposure time of the filter in seconds.\n        If not provided, the full filter exposure time is used.\n\n    Returns\n    -------\n    Quantity[int]\n        The corresponding flux in electron counts\n\n    Example\n    -------\n    &gt;&gt;&gt; from surveycodex.utilities import mag2counts\n    &gt;&gt;&gt; mag2counts(24, \"LSST\", \"g\")\n    &lt;Quantity 121397 ct&gt;\n\n    References\n    ----------\n    The `WeakLensingDeblending` package\n    https://github.com/LSSTDESC/WeakLensingDeblending\n\n    \"\"\"\n    if not isinstance(magnitude, u.Quantity):\n        magnitude *= u.mag(u.electron / u.s)\n    else:\n        magnitude = magnitude.value * u.mag(u.electron / u.s)\n\n    if not isinstance(survey, Survey):\n        survey = get_survey(survey)\n\n    if not isinstance(filter, Filter):\n        filter = survey.get_filter(filter)\n\n    flux = (magnitude - filter.zeropoint).to(u.electron / u.s)\n\n    exposure_time = exposure_time or filter.full_exposure_time\n    if not isinstance(exposure_time, u.Quantity):\n        exposure_time *= u.s\n\n    counts = flux * exposure_time\n\n    return counts.astype(int)\n</code></pre>"},{"location":"api/utilities.html#surveycodex.utilities.mean_sky_level","title":"<code>mean_sky_level(survey, filter)</code>","text":"<p>Computes the mean sky level for a given survey and a filter</p> <p>This computation uses the sky brightness parameter from surveycodex, expressed as a magnitude per sky area, weights it by the pixel area and converts it to electron counts.</p>"},{"location":"api/utilities.html#surveycodex.utilities.mean_sky_level--parameters","title":"Parameters","text":"<p>survey: str or Survey     Name of a given survey or Survey instance filter: str or Filter     Name of the survey filter of Filter instance</p>"},{"location":"api/utilities.html#surveycodex.utilities.mean_sky_level--returns","title":"Returns","text":"<p>Quantity[float]     The corresponding mean sky level in electron counts</p>"},{"location":"api/utilities.html#surveycodex.utilities.mean_sky_level--example","title":"Example","text":"<p>from surveycodex.utilities import mean_sky_level mean_sky_level(\"LSST\", \"g\")  Source code in <code>surveycodex/utilities.py</code> <pre><code>def mean_sky_level(survey, filter):\n    \"\"\"Computes the mean sky level for a given survey and a filter\n\n    This computation uses the sky brightness parameter from surveycodex,\n    expressed as a magnitude per sky area, weights it by the\n    pixel area and converts it to electron counts.\n\n    Parameters\n    ----------\n    survey: str or Survey\n        Name of a given survey or Survey instance\n    filter: str or Filter\n        Name of the survey filter of Filter instance\n\n    Returns\n    -------\n    Quantity[float]\n        The corresponding mean sky level in electron counts\n\n    Example\n    -------\n    &gt;&gt;&gt; from surveycodex.utilities import mean_sky_level\n    &gt;&gt;&gt; mean_sky_level(\"LSST\", \"g\")\n    &lt;Quantity 23241.84 ct&gt;\n\n    \"\"\"\n    if not isinstance(survey, Survey):\n        survey = get_survey(survey)\n\n    if not isinstance(filter, Filter):\n        filter = survey.get_filter(filter)\n\n    sky_brightness_counts = mag2counts(filter.sky_brightness, survey, filter)\n    pixel_area = survey.pixel_scale.to_value(u.arcsec) ** 2\n\n    mean_sky_level = sky_brightness_counts * pixel_area\n\n    return mean_sky_level\n</code></pre>"},{"location":"guides/create-galaxy.html","title":"Simulate a simple galaxy with surveycodex and GalSim","text":"<p>In this tutorial, we will see how we can use the survey parameters in surveycodex to create a simple elliptical galaxy with galsim. The galaxy will be convolved with a optical+atmospheric component PSF, include background and noise, and use the r-band filter of the LSST survey.</p> <p>Please note that <code>galsim</code> is not a <code>surveycodex</code> dependency, so it must be installed separately to follow this guide. See here for <code>galsim</code> installation instructions.</p> <p>To draw the image at the end of the tutorial, <code>matplotlib</code> will also need to be installed separately.</p> <p>First, we import galsim and necessary functions from surveycodex.</p> <pre><code>import galsim\nimport surveycodex\nfrom surveycodex import get_survey\nfrom surveycodex import utilities\nimport matplotlib.pyplot as plt\nimport numpy as np\n</code></pre> <p>Then, we specify the survey and filter from surveycodex we will use. Along with galaxy parameters.</p> <pre><code># surveycodex survey and filter.\nLSST = get_survey(\"LSST\")\nr_band = LSST.get_filter(\"r\")\n\n# galaxy model parameters\nmag = 22.0 # ab\ne1 = 0.2\ne2 = 0.2\nhlr = 1.2 # arcsecs\n</code></pre> <p>Now we create a galaxy model and shear it.</p> <pre><code># get flux from magnitude using surveycodex for LSST r-band.\ntotal_flux = mag2counts(mag, LSST, r_band)\n\n# get only the value of flux in desired units.\ntotal_flux = total_flux.to_value('electron')\n\n# simple gaussian galaxy with ellipticity\ngal = galsim.Gaussian(flux=total_flux, half_light_radius=hlr)\ngal = gal.shear(e1=e1, e2=e2)\n</code></pre> <p>Now we create a PSF, first the atmospheric component.</p> <pre><code>fwhm = r_band.psf_fwhm.to_value(\"arcsec\")\natmospheric_psf_model = galsim.Kolmogorov(fwhm=fwhm)\n</code></pre> <p>Then, the optical component.</p> <pre><code>effective_wavelength = r_band.effective_wavelength.to_value(\"angstrom\")\nobscuration = LSST.obscuration.value\nmirror_diameter = LSST.mirror_diameter.to_value(\"m\")\nlam_over_diam = 3600 * np.degrees(1e-10 * effective_wavelength / mirror_diameter)\noptical_psf_model = galsim.Airy(lam_over_diam=lam_over_diam, obscuration=obscuration)\n</code></pre> <p>The full PSF is the convolution of both components.</p> <pre><code>psf = galsim.Convolve(atmospheric_psf_model, optical_psf_model)\n</code></pre> <p>We convolve it with the galaxy model</p> <pre><code>conv_gal = galsim.Convolve(gal, psf)\n</code></pre> <p>Finally, we add noise and background:</p> <pre><code># retrieve the sky level using surveycodex.\nsky_level = utilities.mean_sky_level(LSST, r_band).to_value('electron')\n\n# add noise and background to image.\npixel_scale = LSST.pixel_scale.to_value('arcsec')\ngenerator = galsim.random.BaseDeviate(seed=0)\nnoise = galsim.PoissonNoise(rng=generator, sky_level=sky_level)\nimage = conv_gal.drawImage(nx=53, ny=53, scale=pixel_scale)\nimage.addNoise(noise)\n</code></pre> <p>Now <code>image.array</code> can be plotted to see the galaxy that was produced.</p> <pre><code>plt.imshow(image.array)\n</code></pre> <p>We get the following image:</p> <p></p>"},{"location":"guides/getting-started.html","title":"Getting started","text":"<pre><code># The list of available surveys\nfrom surveycodex import available_surveys\n\n# Getter methods to retrieve a Survey of a Filter dataclass\nfrom surveycodex import get_survey, get_filter\n\nLSST = get_survey(\"LSST\")\nu_band = get_filter(\"u\", \"LSST\")\n# which is a proxy for\nu_band = LSST.get_filter(\"u\")\n\n# Get the list of available filters\nLSST.available_filters\n\n# or as a dictionary with all `Filter` objects\nLSST.get_filters()\n\n# Both Survey and Filter classes have physical attributes\nLSST.mirror_diameter\nu_band.full_exposure_time\n\n# Filters are also attributes of a Survey\nLSST.filters.u.full_exposure_time  # same attribute as above\n\n# These attributes are Astropy Quantity objects with units\nfwhm = u_band.psf_fwhm\n# The value in the original units is obtained as\nfwhm.value\n# or it can be converted to other units\nfwhm.to_value('arcmin')\n</code></pre>"},{"location":"guides/heritage.html","title":"Extend surveycodex objects","text":""},{"location":"guides/heritage.html#frozen-dataclasses","title":"Frozen dataclasses","text":"<p>The goal of surveycodex is to provide a sourced reference for survey parameters. Therefore the <code>Survey</code> and <code>Filter</code> objects have been implemented as frozen dataclasses. This means that trying to modify the attributes of an instance of a <code>Survey</code> or a <code>Filter</code> will raise a <code>FrozenInstanceError</code>.</p> <p>Nevertheless, one might possibly want to modify or extend the instances of the dataclasses found in surveycodex for specific purposes. This can be achieved through inheritance.</p>"},{"location":"guides/heritage.html#inheritance","title":"Inheritance","text":"<p>A frozen dataclass creates a class for which the call to the <code>__setattr__</code> method raises a <code>FrozenInstanceError</code>. A short way to bypass that feature is to inherit from the main class and modify the <code>__setattr__</code> method to recover its classic behavior.</p> <pre><code>class ExtensibleSurvey(Survey):\n     def __setattr__(self, x, val):\n         self.__dict__[x] = val\n</code></pre> <p>The <code>ExtensibleSurvey</code> will behave just as the surveycodex <code>Survey</code> and will be extendable or modifiable. This is also true for the <code>Filter</code> class.</p> <p>To be used at you own risk</p>"}]}